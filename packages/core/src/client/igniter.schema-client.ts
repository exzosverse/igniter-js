import type { 
  IgniterRouterSchema, 
  InferRouterCaller, 
  IgniterAction,
  ClientCallerOptions,
  QueryActionCallerResult,
  MutationActionCallerResult,
  ClientCallerFetcher
} from '../types'
import { cache } from 'react'
import { isServer } from '../utils/client'
import { parseURL } from '../utils/url'
import { createUseQuery, createUseMutation } from './igniter.hooks'
import { parseResponse } from '../utils/response'

/**
 * Configuration for schema-based client
 */
export interface SchemaClientConfig<TSchema extends IgniterRouterSchema<any, any>> {
  /**
   * Base URL for API requests
   */
  baseUrl: string
  
  /**
   * Clean router schema (no server code)
   */
  schema: TSchema
  
  /**
   * Optional server router getter for hybrid execution
   * Only used in server environment for direct calls
   */
  getServerRouter?: () => Promise<any> | null
}

/**
 * Creates a schema-based client that eliminates bundle contamination
 * 
 * This client uses a clean schema instead of the full router, ensuring
 * that server-side code (handlers, middleware, dependencies) never 
 * contaminate the client bundle.
 * 
 * @template TSchema - The router schema type
 * @param config - Client configuration
 * @returns Type-safe client with full inference
 * 
 * @example
 * ```typescript
 * // Generated by CLI
 * export const api = createIgniterSchemaClient<AppRouterSchema>({
 *   baseUrl: '/api/v1',
 *   schema: AppRouterSchemaData,
 *   getServerRouter: () => import('@/igniter.router').then(m => m.AppRouter)
 * })
 * 
 * // Usage in Server Components
 * const users = await api.users.list.query()
 * 
 * // Usage in Client Components  
 * const { data } = api.users.list.useQuery()
 * ```
 */
export const createIgniterSchemaClient = <TSchema extends IgniterRouterSchema<any, any>>(
  config: SchemaClientConfig<TSchema>
): InferRouterCaller<TSchema> => {
  if (!config.schema) {
    throw new Error('Schema is required to create an Igniter schema client')
  }

  const client = {} as InferRouterCaller<TSchema>

  // Build client structure from SCHEMA (not router) - bundle safe
  for (const controllerName in config.schema.controllers) {
    client[controllerName as keyof typeof client] = {} as any
    const controller = config.schema.controllers[controllerName]

    for (const actionName in controller.actions) {
      const action = controller.actions[actionName]

      // Create hybrid caller that tries direct execution first, then HTTP
      const caller = createHybridCaller(
        config,
        controllerName,
        actionName,
        action,
        controller.path
      )

      // Store action path for caching in hooks
      ;(caller as any).__actionPath = `${controllerName}.${actionName}`

      // Add methods based on HTTP method
      if (action.method === 'GET') {
        ;(client[controllerName as keyof typeof client] as any)[actionName] = {
          useQuery: !isServer ? createUseQuery(caller) : () => ({} as QueryActionCallerResult<any>),
          query: caller,
        }
      } else {
        ;(client[controllerName as keyof typeof client] as any)[actionName] = {
          useMutation: !isServer ? createUseMutation(caller) : () => ({} as MutationActionCallerResult<any>),
          mutate: caller,
        }
      }
    }
  }

  return client
}

/**
 * Create hybrid caller that tries direct execution first, then HTTP fallback
 */
const createHybridCaller = (
  config: SchemaClientConfig<any>,
  controllerName: string,
  actionName: string,
  action: any,
  controllerPath: string
) => {
  return cache(async (input?: ClientCallerOptions<any>) => {
    // Try direct execution in server environment (best performance)
    if (isServer && config.getServerRouter) {
      try {
        const router = await config.getServerRouter()
        if (router?.processor?.call) {
          const result = await router.processor.call(controllerName, actionName, input)
          return result
        }
      } catch (error) {
        // Silently fall back to HTTP - this is expected in many scenarios
        // (build time, edge functions, cold starts, etc.)
        if (process.env.NODE_ENV === 'development') {
          console.warn(
            `Direct call failed for ${controllerName}.${actionName}, using HTTP fallback:`,
            error instanceof Error ? error.message : error
          )
        }
      }
    }

    // HTTP fallback (always works, consistent behavior)
    return await httpFetcher(config.baseUrl, action, controllerPath, input)
  })
}

/**
 * HTTP fetcher for API requests
 */
const httpFetcher = async (
  baseUrl: string,
  action: any,
  controllerPath: string,
  options?: ClientCallerOptions<any>
): Promise<any> => {
  // Extract path parameters
  const params = options?.params || {}
  let path = action.path

  // Replace path parameters in the URL
  for (const param in params) {
    path = path.replace(`:${param}`, encodeURIComponent(String(params[param])))
  }

  // Construct full URL
  let url = parseURL(baseUrl, controllerPath, path)

  // Add query parameters for GET requests
  if (action.method === 'GET' && options?.query) {
    const queryParams = new URLSearchParams()
    for (const key in options.query) {
      queryParams.append(key, String(options.query[key]))
    }
    if (queryParams.toString()) {
      url += `?${queryParams.toString()}`
    }
  }

  // Prepare request options
  const requestOptions: RequestInit = {
    method: action.method,
    headers: {
      'Content-Type': 'application/json',
    },
  }

  // Add body for non-GET requests
  if (action.method !== 'GET' && options?.body) {
    requestOptions.body = JSON.stringify(options.body)
  }

  // Make the request
  const response = await fetch(url, requestOptions)
  
  // Parse response (reuse existing utility)
  const result = await parseResponse(response)
  return result
} 