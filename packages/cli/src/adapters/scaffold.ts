import * as fs from 'fs/promises'
import * as path from 'path'
import chalk from 'chalk'
import { createChildLogger } from './logger'
import { PrismaProvider } from './scaffold/providers/prisma'
import { SchemaProvider, ModelSchema } from './scaffold/providers/base'

const logger = createChildLogger({ component: 'scaffold' })

// --- Helper Functions ---

/**
 * Check if a Prisma schema file exists in the current project
 */
async function hasPrismaSchema(): Promise<boolean> {
  const possiblePaths = [
    path.join(process.cwd(), 'prisma', 'schema.prisma'),
    path.join(process.cwd(), 'schema.prisma')
  ]
  
  for (const schemaPath of possiblePaths) {
    try {
      await fs.access(schemaPath)
      return true
    } catch {
      // Continue checking other paths
    }
  }
  
  return false
}

/**
 * Get available Prisma models from the schema
 */
async function getPrismaModels(): Promise<string[]> {
  try {
    const provider = new PrismaProvider()
    return await provider.listModels()
  } catch (error) {
    logger.debug('Failed to get Prisma models', { error })
    return []
  }
}

function toPascalCase(str: string): string {
  return str.replace(/(^\w|-\w)/g, g => g.replace(/-/, '').toUpperCase())
}

function toCamelCase(str: string): string {
    const pascal = toPascalCase(str)
    return pascal.charAt(0).toLowerCase() + pascal.slice(1)
}

async function writeFile(filePath: string, content: string): Promise<void> {
  const dir = path.dirname(filePath);
  await fs.mkdir(dir, { recursive: true });
  await fs.writeFile(filePath, content, 'utf-8');
}


// --- Schema Provider Factory ---

function getSchemaProvider(providerName: string): SchemaProvider {
  if (providerName.toLowerCase() === 'prisma') {
    return new PrismaProvider();
  }
  // Future providers like Drizzle would be added here
  // else if (providerName.toLowerCase() === 'drizzle') {
  //   return new DrizzleProvider();
  // }
  throw new Error(`Unsupported schema provider: ${providerName}`);
}

// --- CRUD Template Generators ---

function generateCrudInterfacesTemplate(model: ModelSchema, featureName?: string): string {
  const modelNamePascal = toPascalCase(model.name);

  const zodFields = model.fields
    .filter(field => !field.isRelation) // Exclude relation fields
    .map(field => {
      let zodType: string;
      switch (field.type) {
        case 'string':
        case 'bigint':
          zodType = 'z.string()';
          break;
        case 'number':
          zodType = 'z.number()';
          break;
        case 'boolean':
          zodType = 'z.boolean()';
          break;
        case 'Date':
           zodType = 'z.date()';
           break;
        default:
          zodType = `z.any() // Type '${field.type}' not directly supported`;
      }
      if (!field.isRequired) {
        // For Prisma, optional fields are nullable
        zodType += '.nullable()';
      }
      return `  ${field.name}: ${zodType},`;
    }).join('\n');

  const createInputOmissions = model.fields
      .filter(f => f.isId || f.isAutoGenerated)
      .map(f => `  ${f.name}: true,`)
      .join('\n');

  return `import { z } from 'zod';

// Generated from your '${model.name}' Prisma model
export const ${modelNamePascal}Schema = z.object({
${zodFields}
});

// Schema for creating a new ${model.name}.
// Fields managed by the database (id, createdAt, etc.) are omitted.
export const Create${modelNamePascal}InputSchema = ${modelNamePascal}Schema.omit({
${createInputOmissions}
});

// Schema for updating a ${model.name}. All fields are optional.
export const Update${modelNamePascal}InputSchema = Create${modelNamePascal}InputSchema.partial();

// Exporting types for convenience
export type ${modelNamePascal} = z.infer<typeof ${modelNamePascal}Schema>;
export type Create${modelNamePascal}Input = z.infer<typeof Create${modelNamePascal}InputSchema>;
export type Update${modelNamePascal}Input = z.infer<typeof Update${modelNamePascal}InputSchema>;
`;
}


function generateCrudProcedureTemplate(model: ModelSchema, featureName?: string): string {
    const modelNameCamel = toCamelCase(model.name);
    const modelNamePascal = toPascalCase(model.name);
    const idField = model.fields.find(f => f.isId);
    if (!idField) throw new Error(`Model ${model.name} has no ID field.`);

    return `import { igniter } from '@/igniter';
import type { Create${modelNamePascal}Input, Update${modelNamePascal}Input } from '../${featureName}.interfaces';

export const ${modelNameCamel}Procedure = igniter.procedure({
  name: '${modelNameCamel}',
  handler: async (_, { context }) => {
    // This procedure acts as a repository, centralizing database access logic.
    return {
      ${modelNameCamel}Repository: {
        findAll: () => context.database.${modelNameCamel}.findMany(),
        findById: (id: ${idField.type}) => context.database.${modelNameCamel}.findUnique({ where: { id } }),
        create: (data: Create${modelNamePascal}Input) => context.database.${modelNameCamel}.create({ data }),
        update: (id: ${idField.type}, data: Update${modelNamePascal}Input) => context.database.${modelNameCamel}.update({ where: { id }, data }),
        delete: (id: ${idField.type}) => context.database.${modelNameCamel}.delete({ where: { id } }),
      }
    };
  }
});
`;
}

function generateCrudControllerTemplate(model: ModelSchema, featureName?: string): string {
    const modelNameCamel = toCamelCase(model.name);
    const modelNamePascal = toPascalCase(model.name);

    const idField = model.fields.find(f => f.isId);
    if (!idField) throw new Error(`Model ${model.name} has no ID field.`);

    let idZodType = 'z.string()';
    if(idField.type === 'number') idZodType = 'z.coerce.number()';

    return `import { igniter } from '@/igniter';
import { z } from 'zod';
import { ${modelNameCamel}Procedure } from '../procedures/${featureName}.procedure'
import { Create${modelNamePascal}InputSchema, Update${modelNamePascal}InputSchema } from '../${featureName}.interfaces'

export const ${modelNameCamel}Controller = igniter.controller({
  name: '${modelNamePascal}',
  description: 'Endpoints for ${modelNamePascal}s',
  path: '/${modelNameCamel}s', // e.g., /users
  actions: {
    list: igniter.query({
      name: 'list',
      description: 'List all ${modelNamePascal}s',
      path: '/',
      use: [${modelNameCamel}Procedure()],
      handler: async ({ context, response }) => {
        const records = await context.${modelNameCamel}Repository.findAll()
        return response.success(records)
      },
    }),

    getById: igniter.query({
      name: 'getById',
      description: 'Get a ${modelNamePascal} by ID',
      path: '/:id' as const,
      use: [${modelNameCamel}Procedure()],
      handler: async ({ request, context, response }) => {
        const record = await context.${modelNameCamel}Repository.findById(request.params.id)
        if (!record) {
          return response.notFound('${modelNamePascal} not found')
        }
        return response.success(record)
      },
    }),

    create: igniter.mutation({
      name: 'create',
      description: 'Create a new ${modelNamePascal}',
      path: '/',
      method: 'POST',
      body: Create${modelNamePascal}InputSchema,
      use: [${modelNameCamel}Procedure()],
      handler: async ({ request, context, response }) => {
        const newRecord = await context.${modelNameCamel}Repository.create(request.body)
        return response.created(newRecord)
      },
    }),

    update: igniter.mutation({
      name: 'update',
      description: 'Update a ${modelNamePascal} by ID',
      path: '/:id' as const,
      method: 'PUT',
      body: Update${modelNamePascal}InputSchema,
      use: [${modelNameCamel}Procedure()],
      handler: async ({ request, context, response }) => {
        const updatedRecord = await context.${modelNameCamel}Repository.update(request.params.id, request.body)
        return response.success(updatedRecord)
      },
    }),

    delete: igniter.mutation({
      name: 'delete',
      description: 'Delete a ${modelNamePascal} by ID',
      path: '/:id' as const,
      method: 'DELETE',
      use: [${modelNameCamel}Procedure()],
      handler: async ({ request, context, response }) => {
        await context.${modelNameCamel}Repository.delete(request.params.id)
        return response.noContent()
      },
    }),
  },
})
`
}

function generateCrudIndexTemplate(featureName: string): string {
    const procedureFileName = `${featureName}.procedure`
    const controllerFileName = `${featureName}.controller`
    const interfacesFileName = `${featureName}.interfaces`

    return `export * from './controllers/${controllerFileName}'
export * from './procedures/${procedureFileName}'
export * from './${interfacesFileName}'
`
}


// --- Empty Feature Template Generators ---

function generateEmptyControllerTemplate(featureName: string): string {
  const controllerName = `${featureName.toLowerCase()}Controller`
  return `import { igniter } from '@/igniter'
import { z } from 'zod'

export const ${controllerName} = igniter.controller({
  name: '${featureName}',
  path: '/${featureName}',
  actions: {
    hello: igniter.query({
      path: '/hello',
      handler: async ({ response }) => {
        return response.success({ message: 'Hello from ${featureName}!' })
      },
    }),
  },
})
`
}

function generateEmptyInterfacesTemplate(featureName: string): string {
  return `// Zod schemas and TypeScript types for the ${featureName} feature.
`
}

function generateEmptyIndexTemplate(featureName: string): string {
  return `export * from './controllers/${featureName}.controller'
`
}

// --- Main Scaffolding Logic ---

async function scaffoldEmptyFeature(featureName: string, featureDir: string) {
    logger.info(`Creating empty feature '${featureName}'...`)

    try {
        await fs.mkdir(path.join(featureDir, 'controllers'), { recursive: true })
        await fs.mkdir(path.join(featureDir, 'procedures'), { recursive: true })

        await writeFile(
            path.join(featureDir, 'controllers', `${featureName}.controller.ts`),
            generateEmptyControllerTemplate(featureName)
        )
        await writeFile(
            path.join(featureDir, `${featureName}.interfaces.ts`),
            generateEmptyInterfacesTemplate(featureName)
        )
        await writeFile(
            path.join(featureDir, 'index.ts'),
            generateEmptyIndexTemplate(featureName)
        )
        logger.success(`Scaffolded empty feature '${featureName}'`)
    } catch(error) {
        logger.error(`Failed to create empty feature '${featureName}'`)
        throw error
    }
}


async function scaffoldFeatureFromSchema(featureName: string, schemaString: string, featureDir: string) {
    logger.info(`Scaffolding feature '${featureName}' from schema...`)

    try {
        const [providerName, modelName] = schemaString.split(':')
        if (!providerName || !modelName) {
            throw new Error('Invalid schema format. Expected `provider:ModelName` (e.g., `prisma:User`).')
        }

        const provider = getSchemaProvider(providerName)
        const model = await provider.getModel(modelName)

        if (!model) {
            throw new Error(`Model '${modelName}' not found using provider '${providerName}'.`)
        }

        logger.info('Generating files from model schema...')

        await fs.mkdir(path.join(featureDir, 'controllers'), { recursive: true })
        await fs.mkdir(path.join(featureDir, 'procedures'), { recursive: true })

        await writeFile(
            path.join(featureDir, `${featureName}.interfaces.ts`),
            generateCrudInterfacesTemplate(model, featureName)
        )
        await writeFile(
            path.join(featureDir, 'procedures', `${featureName}.procedure.ts`),
            generateCrudProcedureTemplate(model, featureName)
        )
        await writeFile(
            path.join(featureDir, 'controllers', `${featureName}.controller.ts`),
            generateCrudControllerTemplate(model, featureName)
        )
        await writeFile(
            path.join(featureDir, 'index.ts'),
            generateCrudIndexTemplate(featureName)
        )

        logger.success(`Successfully scaffolded feature '${featureName}' from '${modelName}' model.`)
        console.log(chalk.cyan(`\n✅ Next step: Register the '${toCamelCase(featureName)}Controller' in 'src/igniter.router.ts'`))

    } catch (error) {
        logger.error(`Failed to scaffold feature from schema`)
        throw error
    }
}


export async function handleGenerateFeature(
  name: string | undefined,
  options: { schema?: string } = {}
): Promise<void> {
  let featureName = name
  
  // Interactive wizard when no name is provided
  if (!featureName) {
    const prompts = await import('prompts')
    
    // Check if Prisma schema is available
    const hasPrisma = await hasPrismaSchema()
    const prismaModels = hasPrisma ? await getPrismaModels() : []
    
    const questions: any[] = [
      {
        type: 'text',
        name: 'featureName',
        message: 'What is the name of your feature?',
        validate: (input: string) => {
          if (!input.trim()) {
            return 'Feature name is required'
          }
          if (!/^[a-zA-Z][a-zA-Z0-9-_]*$/.test(input)) {
            return 'Feature name must start with a letter and contain only letters, numbers, hyphens, and underscores'
          }
          return true
        }
      }
    ]
    
    // Add Prisma model selection if available
    if (hasPrisma && prismaModels.length > 0) {
      questions.push({
        type: 'select',
        name: 'useModel',
        message: 'Would you like to generate CRUD operations from a Prisma model?',
        choices: [
          { title: 'No, create an empty feature', value: 'none' },
          { title: 'Yes, select a Prisma model', value: 'select' }
        ],
        initial: 0
      })
      
      questions.push({
        type: (prev: string) => prev === 'select' ? 'select' : null,
        name: 'selectedModel',
        message: 'Which Prisma model would you like to use?',
        choices: prismaModels.map(model => ({ title: model, value: model }))
      })
    }
    
    const response = await prompts.default(questions)
    
    if (!response.featureName) {
      logger.error('Feature name is required')
      process.exit(1)
    }
    
    featureName = response.featureName
    
    // If user selected a Prisma model, set it as the schema option with proper format
     if (response.useModel === 'select' && response.selectedModel) {
       options.schema = `prisma:${response.selectedModel}`
     }
   }
   
   // At this point, featureName is guaranteed to be defined
   const normalizedName = featureName!.toLowerCase()
  const featureDir = path.join(process.cwd(), 'src', 'features', normalizedName)

  logger.info(`Scaffolding feature: ${chalk.cyan(normalizedName)}`)

  try {
    await fs.access(featureDir)
    logger.error(`Feature '${normalizedName}' already exists.`)
    console.error(chalk.red(`✗ Feature '${normalizedName}' already exists at ${path.relative(process.cwd(), featureDir)}`))
    return
  } catch (error) {
    // Directory does not exist, which is what we want.
  }

  if (options.schema) {
    await scaffoldFeatureFromSchema(normalizedName, options.schema, featureDir)
  } else {
    await scaffoldEmptyFeature(normalizedName, featureDir)
  }
}

// Stub for future commands
export async function handleGenerateController(name: string, feature: string): Promise<void> {
    logger.warn(`'generate controller' is not yet fully implemented. Use 'generate feature --schema' instead.`)
}
export async function handleGenerateProcedure(name: string, feature: string): Promise<void> {
    logger.warn(`'generate procedure' is not yet fully implemented. Use 'generate feature --schema' instead.`)
}
