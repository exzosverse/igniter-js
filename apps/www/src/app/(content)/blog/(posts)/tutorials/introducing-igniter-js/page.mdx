# Introducing Igniter.js: The Type-Safe Full-Stack Framework for Modern Web Development

In the rapidly evolving landscape of web development, developers are constantly seeking tools that not only boost productivity but also ensure code reliability and maintainability. Today, we're excited to introduce **Igniter.js**, a groundbreaking TypeScript framework that redefines how we build full-stack applications with unprecedented type safety, seamless real-time capabilities, and an exceptional developer experience.

Created by [Felipe Barcelos](https://github.com/felipebarcelospro), Igniter.js emerges from years of experience building scalable web applications and recognizing the gaps in existing solutions. This framework addresses the fundamental challenges developers face when building modern applications: maintaining type safety across the entire stack, managing complex state synchronization, and building robust backend services without sacrificing performance or developer experience.

## The Problem with Current Full-Stack Development

Modern web development often involves juggling multiple technologies, each with its own paradigms and type systems. Developers typically face several challenges:

### 1. **Type Safety Boundaries**
Traditional full-stack development creates artificial boundaries between frontend and backend code. Even with TypeScript on both sides, the communication layer—APIs, database queries, and client-server interactions—often lacks proper type safety, leading to runtime errors and maintenance headaches.

### 2. **Complex State Management**
Keeping client-side state synchronized with server-side data requires intricate solutions involving caching, invalidation strategies, and real-time updates. Most frameworks treat these as separate concerns, adding complexity to the development process.

### 3. **Backend Infrastructure Complexity**
Building robust backend services requires integrating multiple systems: databases, caching, background jobs, pub/sub messaging, and real-time updates. Each system typically requires separate configuration and lacks unified type safety.

### 4. **Developer Experience Fragmentation**
Developers often switch between different mental models, toolchains, and debugging approaches when working across the stack, reducing productivity and increasing cognitive load.

## Enter Igniter.js: A Paradigm Shift

Igniter.js addresses these challenges through a unified, type-safe approach that treats your entire application as a cohesive system rather than separate frontend and backend components.

### Core Philosophy

Igniter.js is built on three fundamental principles:

1. **End-to-End Type Safety**: Every piece of data flowing through your application is type-safe, from database queries to UI components.
2. **Developer Experience First**: The framework prioritizes intuitive APIs, excellent tooling, and minimal boilerplate.
3. **Unified Backend Architecture**: All backend services (APIs, jobs, caching, real-time) work together seamlessly with shared type safety.

## Key Features That Set Igniter.js Apart

### 1. **Type-Safe Controllers and Actions**

Igniter.js introduces a revolutionary approach to API development using controllers and actions that ensure complete type safety:

```typescript
// features/users/controllers/users.controller.ts
export const userController = igniter.controller({
  path: '/users',
  actions: {
    // Type-safe query with automatic validation
    getUser: igniter.query({
      path: '/:id' as const,
      query: z.object({
        id: z.string()
      }),
      handler: async ({ request, response, context }) => {
        const user = await context.db.user.findUnique({
          where: { id: request.query.id }
        });

        if (!user) {
          return response.notFound('User not found');
        }

        return response.success(user);
      },
    }),
    
    // Type-safe mutation with validation
    createUser: igniter.mutate({
      path: '/',
      method: 'POST',
      body: z.object({
        name: z.string().min(1),
        email: z.string().email()
      }),
      handler: async ({ request, response, context }) => {
        const user = await context.db.user.create({
          data: request.body
        });
        
        return response.success({ user }, { status: 201 });
      }
    })
  }
});
```

On the client side, consuming this API is equally type-safe and intuitive:

```tsx
'use client';

import { api } from '@/igniter.client';

function UserProfile({ userId }: { userId: string }) {
  // Fully typed query with automatic caching and revalidation
  const userQuery = api.users.getUser.useQuery({
    query: { id: userId },
    enabled: !!userId,
    staleTime: 5000,
    refetchOnWindowFocus: false,
    onSuccess: (data) => {
      console.log('Successfully fetched user:', data);
    },
    onError: (error) => {
      console.error('Error fetching user:', error);
    },
  });
  
  const createUserMutation = api.users.createUser.useMutation({
    onSuccess: (data) => {
      console.log('User created successfully:', data.user);
      // Invalidate and refetch user queries
      userQuery.refetch();
    },
    onError: (error) => {
      console.error('Failed to create user:', error.message);
    }
  });
  
  if (userQuery.isLoading) {
    return <div>Loading user...</div>;
  }
  
  if (userQuery.isError) {
    return <div>Error loading user: {userQuery.error.message}</div>;
  }
  
  return (
    <div>
      <h1>{userQuery.data?.name}</h1>
      <p>{userQuery.data?.email}</p>
      
      <button 
        onClick={() => createUserMutation.mutate({
          body: {
            name: 'John Doe',
            email: 'john@example.com'
          }
        })}
        disabled={createUserMutation.isLoading}
      >
        {createUserMutation.isLoading ? 'Creating...' : 'Create User'}
      </button>
    </div>
  );
}
```

### 2. **Procedures: Reusable Type-Safe Middleware**

Igniter.js provides a powerful procedure system for creating reusable, type-safe middleware that can extend your application context:

```typescript
// procedures/auth.procedure.ts
export const auth = igniter.procedure({
  handler: async (options: { isAuthRequired: boolean }, { response, context }) => {
    const user = await getCurrentUser(context.env.SECRET);

    // If auth is required but there's no user, return an unauthorized error.
    // This stops the request from proceeding further.
    if (options.isAuthRequired && !user) {
      return response.unauthorized('Authentication required.');
    }

    // The returned object is merged into the context.
    // Now, context.auth.user will be available in our controller.
    return {
      auth: {
        user,
      },
    };
  },
});

// Usage in controller
export const userController = igniter.controller({
  path: '/users',
  actions: {
    getCurrentUser: igniter.query({
      path: '/me',
      // Use the procedure created in the previous step.
      // TypeScript knows that context.auth.user is now available!
      use: [auth({ isAuthRequired: true })],
      handler: async ({ request, response, context }) => {
        // You can get fully type-safe user object from Auth Procedure
        const user = context.auth.user;

        // Return current session user
        return response.success(user);
      },
    }),
  }
});
```

### 3. **Real-Time Updates by Default**

Igniter.js automatically keeps your UI synchronized with server state through automatic revalidation. When a mutation occurs, the server can trigger client-side data refetches instantly:

```typescript
// Backend: Regular query and mutation with automatic revalidation
export const postsController = igniter.controller({
  path: '/posts',
  actions: {
    // A regular query to list posts
    list: igniter.query({
      path: '/',
      stream: true,
      handler: async ({ context, response }) => {
        const posts = await context.database.post.findMany();
        return response.success({ posts });
      },
    }),

    // A mutation that triggers automatic revalidation
    create: igniter.mutate({
      path: '/',
      body: z.object({ 
        title: z.string(), 
        content: z.string() 
      }),
      handler: async ({ body, context, response }) => {
        const newPost = await context.database.post.create({ 
          data: body 
        });

        // This automatically triggers revalidation for all clients
        // using api.posts.list.useQuery() - no additional code needed!
        return response.created(newPost).revalidate(['posts.list']);
      },
    }),
  },
});

// Frontend: Standard useQuery - automatically updates in real-time
function PostsList() {
  const postsQuery = api.posts.list.useQuery();

  if (postsQuery.isLoading) {
    return <div>Loading posts...</div>;
  }

  return (
    <ul>
      {postsQuery.data?.posts.map((post) => (
        <li key={post.id}>{post.title}</li>
      ))}
    </ul>
  );
}

// When ANY user creates a post, ALL users see the update instantly!
// No WebSockets, no manual refetching, no additional complexity.
```

### 4. **Background Jobs with Type Safety**

Igniter.js includes a powerful job system for handling background processing with full type safety:

```typescript
// src/services/jobs.ts

// Creates a set of registered jobs, using the merge method to add new jobs
export const registeredJobs = jobs.merge({
  // Defines a group of jobs related to emails
  emails: jobs.router({
    jobs: {
      // Registers the 'sendWelcome' job
      sendWelcome: jobs.register({
        name: 'sendWelcome', // Job name
        input: z.object({
          message: z.string() // Defines the input format using Zod (type validation)
        }),
        handler: async ({ input }) => {
          // Function to be executed when the job runs
          console.log(input.message) // Displays the received message in the console
        }
      })
    }
  })
})

// Enqueue jobs from anywhere
export const userController = igniter.controller({
  path: '/users',
  actions: {
    create: igniter.mutate({
      path: '/',
      body: z.object({
        name: z.string(),
        email: z.string().email(),
      }),
      handler: async ({ body, context }) => {
        const user = await context.database.user.create({
          data: body,
        });

        // Enqueue welcome email job
        await igniter.jobs.emails.enqueue({
          task: 'sendWelcome',
          input: {
            userId: user.id,
            email: user.email,
          },
        });

        return response.success({ user });
      },
    }),
  },
});
```

## Framework-Agnostic Architecture

Igniter.js is designed to work seamlessly with any JavaScript runtime and framework. The core philosophy is "write once, deploy anywhere":

<Callout type="info">
**Framework Flexibility**: Igniter.js can be integrated with React, Vue, Svelte, Angular, or any other frontend framework. The type-safe client can even be used in mobile applications built with React Native or other cross-platform solutions.
</Callout>

### Integration Examples

**Next.js Integration:**
```typescript
// app/api/[...igniter]/route.ts
import { igniter } from '@/igniter';

// Igniter.js automatically handles all HTTP methods
export const { GET, POST, PUT, DELETE, PATCH } = igniter.nextjs();
```

**Express.js Integration:**
```typescript
// server.ts
import express from 'express';
import { igniter } from './igniter';

const app = express();

// Mount Igniter.js on any path
app.use('/api', igniter.express());

app.listen(3000, () => {
  console.log('Server running on http://localhost:3000');
});
```

**Bun Integration:**
```typescript
// server.ts
import { igniter } from './igniter';

// Direct integration with Bun's native server
Bun.serve({
  port: 3000,
  fetch: igniter.fetch,
});

console.log('Bun server running on http://localhost:3000');
```

**Cloudflare Workers:**
```typescript
// worker.ts
import { igniter } from './igniter';

// Deploy to the edge with zero configuration
export default {
  fetch: igniter.fetch,
};
```

## Performance and Scalability

Igniter.js is engineered for performance and scale from the ground up:

### Key Performance Features

- **Zero Runtime Overhead**: Client-side code is fully tree-shakeable
- **Minimal Bundle Size**: Only ship what you use
- **Fast Cold Starts**: Optimized for serverless environments
- **Type Safety**: 100% end-to-end types with zero performance cost
- **Efficient Serialization**: Optimized data transfer between client and server

### Scalability Architecture

- **Horizontal Scaling**: Stateless design enables easy scaling
- **Edge Deployment**: Native support for edge runtimes (Cloudflare Workers, Vercel Edge)
- **Background Processing**: Reliable job queues with Redis/BullMQ integration
- **Real-time Streaming**: Efficient Server-Sent Events for live data
- **Intelligent Caching**: Built-in query caching with smart invalidation
- **Database Agnostic**: Works with any database or ORM (Prisma, Drizzle, etc.)

### Production Ready

- **Error Handling**: Comprehensive error boundaries and logging
- **Monitoring**: Built-in observability hooks
- **Security**: CORS, rate limiting, and input validation out of the box
- **Testing**: First-class testing utilities for both client and server

## Getting Started with Igniter.js

Starting a new Igniter.js project is incredibly simple thanks to our comprehensive CLI tool:

```bash
# Create a new Igniter.js project
npx @igniter-js/cli init my-app

# Choose your preferred setup
# ✓ Next.js + React
# ✓ TanStack Start
# ✓ Bun + React
# ✓ Express.js API
# ✓ Custom setup

cd my-app
npm run dev
```

The CLI provides several starter templates:

- **[Next.js Starter](/docs/starter-guides/nextjs-starter)**: Full-stack application with App Router
- **[TanStack Start Starter](/docs/starter-guides/tanstack-start-starter)**: Modern React with file-based routing
- **[Bun + React Starter](/docs/starter-guides/bun-react-starter)**: Lightning-fast development with Bun runtime
- **[REST API Starters](/docs/starter-guides/rest-api-starters)**: Backend-only setups for various runtimes

## Comparison with Existing Solutions

Igniter.js stands out in the crowded framework landscape by addressing specific pain points that other solutions leave unresolved:

### vs. tRPC
While [tRPC](https://trpc.io/) provides excellent type safety for API calls, Igniter.js goes further by including integrated queues, real-time updates, AI capabilities, and a more comprehensive developer experience.

### vs. Next.js
[Next.js](https://nextjs.org/) is an excellent React framework, but it doesn't provide backend abstractions or type safety across the full stack. Igniter.js complements Next.js by providing the backend architecture and type-safe communication layer.

### vs. Remix
[Remix](https://remix.run/) offers great full-stack capabilities but is tightly coupled to React and doesn't provide the same level of type safety or AI integration that Igniter.js offers.

### vs. T3 Stack
The [T3 Stack](https://create.t3.gg/) combines excellent tools but requires significant configuration and doesn't provide integrated solutions for queues, real-time updates, or AI. Igniter.js provides all these features out of the box.

## The Road Ahead

Igniter.js is just getting started. Our roadmap includes:

- **Enhanced AI capabilities** with support for more providers and advanced features
- **Visual development tools** for building APIs and managing data flows
- **Advanced caching strategies** with edge computing support
- **Plugin ecosystem** for extending framework capabilities
- **Enterprise features** including advanced monitoring and deployment tools

## Community and Ecosystem

We're building Igniter.js as an open-source project with community collaboration at its core. Here's how you can get involved:

- **[GitHub Repository](https://github.com/felipebarcelospro/igniter-js)**: Contribute code, report issues, or suggest features
- **[Documentation](/docs)**: Comprehensive guides and API references
- **[Discord Community](https://discord.gg/igniter-js)**: Connect with other developers and get support
- **[Blog](/blog)**: Stay updated with the latest developments and tutorials

## Conclusion

Igniter.js represents a new paradigm in full-stack development, where type safety, developer experience, and modern capabilities like AI integration are not afterthoughts but fundamental design principles. By eliminating the traditional boundaries between frontend and backend development, Igniter.js enables developers to build more reliable, maintainable, and feature-rich applications with significantly less complexity.

Whether you're building a simple CRUD application, a complex enterprise system, or an AI-powered platform, Igniter.js provides the tools and abstractions you need to focus on what matters most: delivering value to your users.

Ready to experience the future of full-stack development? [Get started with Igniter.js today](/docs/getting-started/quick-start-guide) and join the growing community of developers who are building the next generation of web applications.

---

*Igniter.js is created and maintained by [Felipe Barcelos](https://github.com/felipebarcelospro) and the open-source community. Special thanks to all contributors who are helping shape the future of full-stack development.*

<Callout type="tip">
**Next Steps**: Ready to dive deeper? Check out our [Quick Start Guide](/docs/getting-started/quick-start-guide) or explore our [starter templates](/docs/starter-guides) to begin building with Igniter.js today.
</Callout>