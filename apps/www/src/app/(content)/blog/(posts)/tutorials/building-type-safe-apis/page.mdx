---
title: "Building Type-Safe APIs with Igniter.js: A Complete Guide to RPC and Builder Patterns"
description: "Learn how to build robust, type-safe APIs using Igniter.js's innovative builder pattern and RPC system. Discover best practices for creating maintainable backend services."
author: "Igniter.js Team"
date: "2024-01-22"
tags: ["api", "typescript", "rpc", "type-safety", "backend"]
category: "Tutorial"
readingTime: "12 min read"
---

# Building Type-Safe APIs with Igniter.js: A Complete Guide to RPC and Builder Patterns

In modern web development, APIs serve as the backbone of communication between frontend and backend systems. However, traditional API development often suffers from a lack of type safety, leading to runtime errors, maintenance challenges, and poor developer experience. Igniter.js revolutionizes API development by introducing a builder pattern that ensures end-to-end type safety while maintaining simplicity and flexibility.

This comprehensive guide will walk you through building robust, type-safe APIs using Igniter.js's innovative approach, covering everything from basic CRUD operations to advanced patterns and best practices.

## The Problem with Traditional API Development

Before diving into Igniter.js solutions, let's examine the common challenges developers face with traditional API development:

### 1. **Type Safety Gaps**
Traditional REST APIs create a disconnect between frontend and backend types. Even with TypeScript on both sides, the API boundary often lacks proper type checking:

```typescript
// Traditional approach - no type safety
app.post('/users', async (req, res) => {
  // req.body is 'any' - no validation or type checking
  const user = await createUser(req.body);
  res.json(user);
});

// Frontend - manual type assertions
const response = await fetch('/users', {
  method: 'POST',
  body: JSON.stringify(userData)
});
const user = await response.json() as User; // Hope it's actually a User!
```

### 2. **Manual Validation and Serialization**
Developers must manually handle input validation, output serialization, and error handling:

```typescript
// Lots of boilerplate for each endpoint
app.post('/users', async (req, res) => {
  try {
    // Manual validation
    if (!req.body.email || !isValidEmail(req.body.email)) {
      return res.status(400).json({ error: 'Invalid email' });
    }
    
    if (!req.body.name || req.body.name.length < 2) {
      return res.status(400).json({ error: 'Name too short' });
    }
    
    const user = await createUser(req.body);
    
    // Manual serialization
    res.status(201).json({
      id: user.id,
      name: user.name,
      email: user.email,
      createdAt: user.createdAt.toISOString()
    });
  } catch (error) {
    // Manual error handling
    res.status(500).json({ error: 'Internal server error' });
  }
});
```

### 3. **Inconsistent Error Handling**
Error responses often lack consistency across different endpoints, making frontend error handling unpredictable.

### 4. **Poor Developer Experience**
Developers lose autocomplete, type checking, and refactoring capabilities when working across the API boundary.

## Igniter.js: A Revolutionary Approach

Igniter.js addresses these challenges through its builder pattern and RPC system, providing:

- **End-to-end type safety** from database to UI
- **Automatic validation** using [Zod](https://zod.dev/) schemas
- **Consistent error handling** with standardized response formats
- **Excellent developer experience** with full autocomplete and type checking
- **Zero boilerplate** for common patterns

## Setting Up Your First Type-Safe API

Let's start by creating a complete user management API to demonstrate Igniter.js capabilities.

### 1. **Project Structure**

First, let's establish a clean project structure:

```
src/
├── features/
│   └── users/
│       ├── controllers/
│       │   └── user.controller.ts
│       ├── schemas/
│       │   └── user.schemas.ts
│       └── services/
│           └── user.service.ts
├── services/
│   ├── database.ts
│   └── context.ts
├── igniter.ts
├── igniter.context.ts
└── igniter.router.ts
```

### 2. **Defining Schemas with Zod**

Start by defining your data schemas using Zod for automatic validation and type inference:

```typescript
// src/features/users/schemas/user.schemas.ts
import { z } from 'zod';

// Input schemas for validation
export const CreateUserSchema = z.object({
  name: z.string()
    .min(2, 'Name must be at least 2 characters')
    .max(50, 'Name must be less than 50 characters'),
  email: z.string()
    .email('Invalid email format')
    .toLowerCase(),
  age: z.number()
    .int('Age must be an integer')
    .min(13, 'Must be at least 13 years old')
    .max(120, 'Age must be realistic'),
  role: z.enum(['user', 'admin', 'moderator'])
    .default('user')
});

export const UpdateUserSchema = CreateUserSchema.partial();

export const UserParamsSchema = z.object({
  id: z.string().uuid('Invalid user ID format')
});

export const UserQuerySchema = z.object({
  page: z.number().int().min(1).default(1),
  limit: z.number().int().min(1).max(100).default(10),
  search: z.string().optional(),
  role: z.enum(['user', 'admin', 'moderator']).optional(),
  sortBy: z.enum(['name', 'email', 'createdAt']).default('createdAt'),
  sortOrder: z.enum(['asc', 'desc']).default('desc')
});

// Output schemas for response typing
export const UserSchema = z.object({
  id: z.string().uuid(),
  name: z.string(),
  email: z.string().email(),
  age: z.number(),
  role: z.enum(['user', 'admin', 'moderator']),
  createdAt: z.date(),
  updatedAt: z.date()
});

export const UserListResponseSchema = z.object({
  users: z.array(UserSchema),
  pagination: z.object({
    page: z.number(),
    limit: z.number(),
    total: z.number(),
    totalPages: z.number()
  })
});

// Type inference for TypeScript
export type CreateUser = z.infer<typeof CreateUserSchema>;
export type UpdateUser = z.infer<typeof UpdateUserSchema>;
export type User = z.infer<typeof UserSchema>;
export type UserListResponse = z.infer<typeof UserListResponseSchema>;
```

### 3. **Creating the User Service**

Implement your business logic in a separate service layer:

```typescript
// src/features/users/services/user.service.ts
import type { CreateUser, UpdateUser, User } from '../schemas/user.schemas';
import type { AppContext } from '@/igniter.context';

export class UserService {
  constructor(private context: AppContext) {}

  async createUser(data: CreateUser): Promise<User> {
    // Check if email already exists
    const existingUser = await this.context.database.user.findUnique({
      where: { email: data.email }
    });

    if (existingUser) {
      throw new Error('Email already exists');
    }

    const user = await this.context.database.user.create({
      data: {
        ...data,
        createdAt: new Date(),
        updatedAt: new Date()
      }
    });

    return user;
  }

  async getUserById(id: string): Promise<User | null> {
    return await this.context.database.user.findUnique({
      where: { id }
    });
  }

  async updateUser(id: string, data: UpdateUser): Promise<User> {
    const user = await this.context.database.user.update({
      where: { id },
      data: {
        ...data,
        updatedAt: new Date()
      }
    });

    return user;
  }

  async deleteUser(id: string): Promise<void> {
    await this.context.database.user.delete({
      where: { id }
    });
  }

  async listUsers(params: {
    page: number;
    limit: number;
    search?: string;
    role?: string;
    sortBy: string;
    sortOrder: 'asc' | 'desc';
  }) {
    const { page, limit, search, role, sortBy, sortOrder } = params;
    const skip = (page - 1) * limit;

    const where = {
      ...(search && {
        OR: [
          { name: { contains: search, mode: 'insensitive' as const } },
          { email: { contains: search, mode: 'insensitive' as const } }
        ]
      }),
      ...(role && { role })
    };

    const [users, total] = await Promise.all([
      this.context.database.user.findMany({
        where,
        skip,
        take: limit,
        orderBy: { [sortBy]: sortOrder }
      }),
      this.context.database.user.count({ where })
    ]);

    return {
      users,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit)
      }
    };
  }
}
```

### 4. **Building the Controller with Igniter.js**

Now, let's create the controller using Igniter.js's builder pattern:

```typescript
// src/features/users/controllers/user.controller.ts
import { igniter } from '@/igniter';
import { 
  CreateUserSchema, 
  UpdateUserSchema, 
  UserParamsSchema, 
  UserQuerySchema,
  UserSchema,
  UserListResponseSchema
} from '../schemas/user.schemas';
import { UserService } from '../services/user.service';

export const userController = igniter.controller({
  path: '/users',
  actions: {
    // GET /users - List users with filtering and pagination
    list: igniter.query({
      path: '/',
      params: UserQuerySchema,
      handler: async ({ params, context, response }) => {
        const userService = new UserService(context);
        const result = await userService.listUsers(params);
        
        return response.success(result);
      }
    }),

    // GET /users/:id - Get user by ID
    getById: igniter.query({
      path: '/:id',
      params: UserParamsSchema,
      handler: async ({ params, context, response }) => {
        const userService = new UserService(context);
        const user = await userService.getUserById(params.id);
        
        if (!user) {
          return response.notFound('User not found');
        }
        
        return response.success(user);
      }
    }),

    // POST /users - Create new user
    create: igniter.mutation({
      path: '/',
      method: 'POST',
      body: CreateUserSchema,
      handler: async ({ request, context, response }) => {
        try {
          const userService = new UserService(context);
          const user = await userService.createUser(request.body);
          
          // Trigger real-time updates for connected clients
          return response.created(user).revalidate(['users.list']);
        } catch (error) {
          if (error.message === 'Email already exists') {
            return response.conflict('Email already exists');
          }
          throw error; // Let Igniter.js handle unexpected errors
        }
      }
    }),

    // PUT /users/:id - Update user
    update: igniter.mutation({
      path: '/:id',
      method: 'PUT',
      params: UserParamsSchema,
      body: UpdateUserSchema,
      handler: async ({ params, request, context, response }) => {
        try {
          const userService = new UserService(context);
          const user = await userService.updateUser(params.id, request.body);
          
          return response.success(user).revalidate([
            'users.list',
            `users.getById.${params.id}`
          ]);
        } catch (error) {
          if (error.code === 'P2025') { // Prisma "Record not found" error
            return response.notFound('User not found');
          }
          throw error;
        }
      }
    }),

    // DELETE /users/:id - Delete user
    delete: igniter.mutation({
      path: '/:id',
      method: 'DELETE',
      params: UserParamsSchema,
      handler: async ({ params, context, response }) => {
        try {
          const userService = new UserService(context);
          await userService.deleteUser(params.id);
          
          return response.noContent().revalidate(['users.list']);
        } catch (error) {
          if (error.code === 'P2025') {
            return response.notFound('User not found');
          }
          throw error;
        }
      }
    })
  }
});
```

## Advanced Patterns and Best Practices

### 1. **Middleware and Authentication**

Igniter.js supports middleware for cross-cutting concerns like authentication:

```typescript
// src/middleware/auth.middleware.ts
import { igniter } from '@/igniter';
import { z } from 'zod';

const AuthHeaderSchema = z.object({
  authorization: z.string().startsWith('Bearer ')
});

export const authMiddleware = igniter.middleware({
  headers: AuthHeaderSchema,
  handler: async ({ headers, context, next }) => {
    const token = headers.authorization.replace('Bearer ', '');
    
    try {
      const user = await context.auth.verifyToken(token);
      
      // Add user to context for downstream handlers
      return next({ 
        context: { 
          ...context, 
          currentUser: user 
        } 
      });
    } catch (error) {
      throw new Error('Invalid or expired token');
    }
  }
});

// Apply middleware to protected routes
export const protectedUserController = igniter.controller({
  path: '/users',
  middleware: [authMiddleware],
  actions: {
    // All actions in this controller are now protected
    profile: igniter.query({
      path: '/profile',
      handler: async ({ context, response }) => {
        // context.currentUser is now available and typed
        return response.success(context.currentUser);
      }
    })
  }
});
```

### 2. **Error Handling and Custom Responses**

Igniter.js provides a comprehensive response system with built-in HTTP status codes:

```typescript
export const userController = igniter.controller({
  path: '/users',
  actions: {
    complexOperation: igniter.mutation({
      path: '/complex',
      method: 'POST',
      body: z.object({ data: z.string() }),
      handler: async ({ request, context, response }) => {
        try {
          // Business logic here
          const result = await performComplexOperation(request.body.data);
          
          return response.success(result);
        } catch (error) {
          // Handle different error types
          if (error instanceof ValidationError) {
            return response.badRequest(error.message);
          }
          
          if (error instanceof NotFoundError) {
            return response.notFound(error.message);
          }
          
          if (error instanceof ConflictError) {
            return response.conflict(error.message);
          }
          
          // Custom error responses
          if (error instanceof RateLimitError) {
            return response.custom(429, {
              error: 'Rate limit exceeded',
              retryAfter: error.retryAfter
            });
          }
          
          // Let Igniter.js handle unexpected errors
          throw error;
        }
      }
    })
  }
});
```

### 3. **Input Transformation and Computed Fields**

Use Zod's transform capabilities for advanced input processing:

```typescript
const CreateUserWithTransformSchema = z.object({
  name: z.string()
    .min(2)
    .transform(name => name.trim().toLowerCase()),
  email: z.string()
    .email()
    .transform(email => email.toLowerCase()),
  birthDate: z.string()
    .datetime()
    .transform(date => new Date(date)),
  tags: z.string()
    .transform(tags => tags.split(',').map(tag => tag.trim()))
    .pipe(z.array(z.string().min(1)))
}).transform(data => ({
  ...data,
  age: new Date().getFullYear() - data.birthDate.getFullYear(),
  slug: data.name.replace(/\s+/g, '-')
}));
```

### 4. **Nested Resources and Relationships**

Handle complex resource relationships elegantly:

```typescript
export const userPostsController = igniter.controller({
  path: '/users/:userId/posts',
  actions: {
    list: igniter.query({
      path: '/',
      params: z.object({
        userId: z.string().uuid(),
        page: z.number().default(1),
        limit: z.number().default(10)
      }),
      handler: async ({ params, context, response }) => {
        // Verify user exists
        const user = await context.database.user.findUnique({
          where: { id: params.userId }
        });
        
        if (!user) {
          return response.notFound('User not found');
        }
        
        const posts = await context.database.post.findMany({
          where: { authorId: params.userId },
          skip: (params.page - 1) * params.limit,
          take: params.limit,
          include: {
            author: true,
            comments: { take: 5 }
          }
        });
        
        return response.success({ posts, user });
      }
    })
  }
});
```

## Client-Side Integration

The real power of Igniter.js shines on the client side with full type safety:

```tsx
// components/UserManagement.tsx
'use client';

import { api } from '@/igniter.client';
import { useState } from 'react';

function UserManagement() {
  const [page, setPage] = useState(1);
  const [search, setSearch] = useState('');
  
  // Fully typed query with automatic caching
  const usersQuery = api.users.list.useQuery({
    page,
    limit: 10,
    search: search || undefined,
    sortBy: 'createdAt',
    sortOrder: 'desc'
  });
  
  // Typed mutations with optimistic updates
  const createUserMutation = api.users.create.useMutation({
    onSuccess: () => {
      // Automatic revalidation triggered by server
      console.log('User created successfully!');
    },
    onError: (error) => {
      // Typed error handling
      if (error.status === 409) {
        alert('Email already exists');
      }
    }
  });
  
  const deleteUserMutation = api.users.delete.useMutation();
  
  if (usersQuery.isLoading) {
    return <div>Loading users...</div>;
  }
  
  if (usersQuery.error) {
    return <div>Error: {usersQuery.error.message}</div>;
  }
  
  return (
    <div>
      <input
        type="text"
        placeholder="Search users..."
        value={search}
        onChange={(e) => setSearch(e.target.value)}
      />
      
      <button
        onClick={() => createUserMutation.mutate({
          name: 'John Doe',
          email: 'john@example.com',
          age: 30,
          role: 'user'
        })}
        disabled={createUserMutation.isPending}
      >
        {createUserMutation.isPending ? 'Creating...' : 'Create User'}
      </button>
      
      <div>
        {usersQuery.data?.users.map(user => (
          <div key={user.id}>
            <h3>{user.name}</h3>
            <p>{user.email} - {user.role}</p>
            <button
              onClick={() => deleteUserMutation.mutate({ id: user.id })}
              disabled={deleteUserMutation.isPending}
            >
              Delete
            </button>
          </div>
        ))}
      </div>
      
      {/* Pagination */}
      <div>
        <button
          onClick={() => setPage(p => Math.max(1, p - 1))}
          disabled={page === 1}
        >
          Previous
        </button>
        
        <span>Page {page} of {usersQuery.data?.pagination.totalPages}</span>
        
        <button
          onClick={() => setPage(p => p + 1)}
          disabled={page >= (usersQuery.data?.pagination.totalPages || 1)}
        >
          Next
        </button>
      </div>
    </div>
  );
}

export default UserManagement;
```

## Performance Optimization

### 1. **Query Optimization**

Use Igniter.js's built-in caching and optimization features:

```typescript
// Optimized query with custom cache key
const optimizedQuery = api.users.list.useQuery(
  { page: 1, limit: 10 },
  {
    staleTime: 5 * 60 * 1000, // 5 minutes
    cacheTime: 10 * 60 * 1000, // 10 minutes
    refetchOnWindowFocus: false,
    select: (data) => {
      // Transform data on the client side
      return {
        ...data,
        users: data.users.map(user => ({
          ...user,
          displayName: `${user.name} (${user.role})`
        }))
      };
    }
  }
);
```

### 2. **Infinite Queries**

Handle large datasets with infinite scrolling:

```typescript
const infiniteUsersQuery = api.users.list.useInfiniteQuery(
  { limit: 20 },
  {
    getNextPageParam: (lastPage) => {
      const { page, totalPages } = lastPage.pagination;
      return page < totalPages ? page + 1 : undefined;
    }
  }
);
```

## Testing Your APIs

Igniter.js makes testing straightforward with full type safety:

```typescript
// tests/user.controller.test.ts
import { describe, it, expect, beforeEach } from 'vitest';
import { createTestContext } from '@/test-utils';
import { userController } from '@/features/users/controllers/user.controller';

describe('User Controller', () => {
  let context: TestContext;
  
  beforeEach(async () => {
    context = await createTestContext();
  });
  
  it('should create a user successfully', async () => {
    const userData = {
      name: 'John Doe',
      email: 'john@example.com',
      age: 30,
      role: 'user' as const
    };
    
    const response = await userController.actions.create.handler({
      request: { body: userData },
      context,
      response: createMockResponse()
    });
    
    expect(response.status).toBe(201);
    expect(response.data).toMatchObject(userData);
  });
  
  it('should return 409 for duplicate email', async () => {
    // Create first user
    await context.database.user.create({
      data: {
        name: 'Existing User',
        email: 'test@example.com',
        age: 25,
        role: 'user'
      }
    });
    
    const response = await userController.actions.create.handler({
      request: { 
        body: {
          name: 'New User',
          email: 'test@example.com', // Duplicate email
          age: 30,
          role: 'user'
        }
      },
      context,
      response: createMockResponse()
    });
    
    expect(response.status).toBe(409);
    expect(response.message).toBe('Email already exists');
  });
});
```

## Conclusion

Igniter.js's builder pattern and RPC system represent a paradigm shift in API development, offering:

- **Complete type safety** from database to UI
- **Automatic validation** and serialization
- **Consistent error handling** across all endpoints
- **Excellent developer experience** with full autocomplete and refactoring support
- **Zero boilerplate** for common patterns
- **Built-in optimization** for performance and caching

By eliminating the traditional boundaries between frontend and backend development, Igniter.js enables developers to build more reliable, maintainable APIs with significantly less code and complexity.

The examples in this guide demonstrate just the beginning of what's possible with Igniter.js. As you build more complex applications, you'll discover that the framework's consistent patterns and type safety make it easy to scale and maintain your codebase.

<Callout type="tip">
**Next Steps**: Ready to implement these patterns in your own project? Check out our [Quick Start Guide](/docs/getting-started/quick-start-guide) or explore our [advanced features documentation](/docs/advanced-features) to learn about queues, real-time updates, and AI integration.
</Callout>

---

*Want to see more examples? Explore our [starter templates](/docs/starter-guides) or join our [Discord community](https://discord.gg/igniter-js) to discuss best practices with other developers.*