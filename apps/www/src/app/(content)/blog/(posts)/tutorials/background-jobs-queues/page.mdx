# Mastering Background Jobs and Queues in Igniter.js: A Complete Guide to Asynchronous Processing

In modern web applications, handling time-consuming tasks efficiently is crucial for maintaining excellent user experience. Whether you're processing file uploads, sending emails, generating reports, or handling data synchronization, background jobs and queues are essential tools in your development arsenal.

Igniter.js provides a powerful, type-safe queue system built on top of industry-standard technologies like BullMQ and Redis. In this comprehensive guide, we'll explore how to implement robust background job processing that scales with your application.

## The Challenge of Synchronous Processing

Traditional web applications often struggle with long-running operations that block the main thread:

```typescript
// ❌ Blocking operation - poor user experience
export const uploadController = new Controller({
  name: 'upload',
  actions: {
    processFile: new Mutation({
      input: z.object({
        fileId: z.string(),
      }),
      handler: async ({ input }) => {
        // This blocks the response for potentially minutes
        const result = await processLargeFile(input.fileId);
        await generateThumbnails(result);
        await updateDatabase(result);
        await sendNotificationEmail(result);
        
        return { success: true, result };
      },
    }),
  },
});
```

This approach leads to:
- **Poor user experience**: Users wait indefinitely for responses
- **Timeout issues**: Requests may fail due to server timeouts
- **Resource blocking**: Server resources are tied up unnecessarily
- **Scalability problems**: Limited concurrent request handling

## Introducing Igniter.js Queue System

Igniter.js solves these challenges with a sophisticated queue system that provides:

- **Type-safe job definitions**: Full TypeScript support for job payloads
- **Reliable processing**: Built on BullMQ for enterprise-grade reliability
- **Flexible scheduling**: Support for delayed, recurring, and priority-based jobs
- **Monitoring and observability**: Built-in job tracking and error handling
- **Horizontal scaling**: Distribute jobs across multiple workers

## Setting Up the Queue System

### Prerequisites

First, install the required dependencies:

```bash
npm install @igniter-js/adapter-bullmq bullmq ioredis
```

### Configuring Redis Connection

Create a Redis configuration in your `src/services/redis.ts`:

```typescript
import { Redis } from 'ioredis';

const redis = new Redis({
  host: process.env.REDIS_HOST || 'localhost',
  port: parseInt(process.env.REDIS_PORT || '6379'),
  password: process.env.REDIS_PASSWORD,
  retryDelayOnFailover: 100,
  enableReadyCheck: false,
  maxRetriesPerRequest: null,
});

export { redis };
```

### Setting Up the Job Adapter

Create your job service in `src/services/jobs.ts`:

```typescript
import { BullMQAdapter } from '@igniter-js/adapter-bullmq';
import { redis } from './redis';

export const jobsAdapter = new BullMQAdapter({
  connection: redis,
  defaultJobOptions: {
    removeOnComplete: 100,
    removeOnFail: 50,
    attempts: 3,
    backoff: {
      type: 'exponential',
      delay: 2000,
    },
  },
});
```

### Registering with Igniter.js

Update your `igniter.ts` configuration:

```typescript
import { Igniter } from '@igniter-js/core';
import { jobsAdapter } from './services/jobs';

export const igniter = new Igniter({
  adapters: {
    jobs: jobsAdapter,
  },
  // ... other configuration
});
```

## Creating Job Routers and Processors

### Defining Job Types

Create type-safe job definitions using Job Routers:

```typescript
// src/jobs/email.jobs.ts
import { JobRouter } from '@igniter-js/core';
import { z } from 'zod';

export const emailJobs = new JobRouter({
  name: 'email',
  jobs: {
    sendWelcomeEmail: {
      input: z.object({
        userId: z.string(),
        email: z.string().email(),
        name: z.string(),
      }),
      processor: async ({ input, job }) => {
        console.log(`Processing welcome email for ${input.name}`);
        
        // Simulate email sending
        await sendEmail({
          to: input.email,
          subject: 'Welcome to our platform!',
          template: 'welcome',
          data: { name: input.name },
        });
        
        console.log(`Welcome email sent to ${input.email}`);
        return { emailSent: true, timestamp: new Date() };
      },
    },
    
    sendPasswordReset: {
      input: z.object({
        email: z.string().email(),
        resetToken: z.string(),
        expiresAt: z.date(),
      }),
      processor: async ({ input }) => {
        await sendEmail({
          to: input.email,
          subject: 'Password Reset Request',
          template: 'password-reset',
          data: {
            resetToken: input.resetToken,
            expiresAt: input.expiresAt,
          },
        });
        
        return { resetEmailSent: true };
      },
    },
  },
});
```

### File Processing Jobs

```typescript
// src/jobs/file.jobs.ts
import { JobRouter } from '@igniter-js/core';
import { z } from 'zod';

export const fileJobs = new JobRouter({
  name: 'file',
  jobs: {
    processUpload: {
      input: z.object({
        fileId: z.string(),
        userId: z.string(),
        originalName: z.string(),
        mimeType: z.string(),
      }),
      processor: async ({ input, job }) => {
        // Update job progress
        await job.updateProgress(10);
        
        // Process the file
        const processedFile = await processFile(input.fileId);
        await job.updateProgress(50);
        
        // Generate thumbnails
        const thumbnails = await generateThumbnails(processedFile);
        await job.updateProgress(80);
        
        // Update database
        await updateFileRecord(input.fileId, {
          status: 'processed',
          thumbnails,
          processedAt: new Date(),
        });
        await job.updateProgress(100);
        
        return {
          fileId: input.fileId,
          thumbnails,
          processedAt: new Date(),
        };
      },
    },
  },
});
```

### Registering Job Routers

Update your `igniter.router.ts`:

```typescript
import { emailJobs } from './jobs/email.jobs';
import { fileJobs } from './jobs/file.jobs';

export const router = {
  // ... your existing controllers
  jobs: {
    email: emailJobs,
    file: fileJobs,
  },
};
```

## Dispatching Jobs from Controllers

Now you can dispatch jobs from your controllers:

```typescript
// src/features/auth/auth.controller.ts
import { Controller, Mutation } from '@igniter-js/core';
import { z } from 'zod';

export const authController = new Controller({
  name: 'auth',
  actions: {
    register: new Mutation({
      input: z.object({
        email: z.string().email(),
        password: z.string().min(8),
        name: z.string(),
      }),
      handler: async ({ input, ctx }) => {
        // Create user account
        const user = await ctx.services.user.create({
          email: input.email,
          password: await hashPassword(input.password),
          name: input.name,
        });
        
        // Dispatch welcome email job
        await ctx.jobs.email.sendWelcomeEmail.dispatch({
          userId: user.id,
          email: user.email,
          name: user.name,
        });
        
        return {
          user: { id: user.id, email: user.email, name: user.name },
          message: 'Account created successfully',
        };
      },
    }),
  },
});
```

## Advanced Job Scheduling

### Delayed Jobs

```typescript
// Schedule a job to run in 1 hour
await ctx.jobs.email.sendPasswordReset.dispatch(
  {
    email: 'user@example.com',
    resetToken: 'abc123',
    expiresAt: new Date(Date.now() + 3600000),
  },
  {
    delay: 3600000, // 1 hour delay
  }
);
```

### Recurring Jobs

```typescript
// src/jobs/maintenance.jobs.ts
export const maintenanceJobs = new JobRouter({
  name: 'maintenance',
  jobs: {
    cleanupTempFiles: {
      input: z.object({}),
      processor: async () => {
        const deletedCount = await cleanupTemporaryFiles();
        console.log(`Cleaned up ${deletedCount} temporary files`);
        return { deletedCount };
      },
    },
  },
});

// Schedule recurring job
await ctx.jobs.maintenance.cleanupTempFiles.dispatch(
  {},
  {
    repeat: {
      cron: '0 2 * * *', // Run daily at 2 AM
    },
  }
);
```

### Priority Jobs

```typescript
// High priority job for critical operations
await ctx.jobs.email.sendPasswordReset.dispatch(
  resetData,
  {
    priority: 10, // Higher number = higher priority
  }
);
```

## Error Handling and Retry Logic

### Custom Error Handling

```typescript
export const paymentJobs = new JobRouter({
  name: 'payment',
  jobs: {
    processPayment: {
      input: z.object({
        paymentId: z.string(),
        amount: z.number(),
        currency: z.string(),
      }),
      processor: async ({ input, job }) => {
        try {
          const result = await processPaymentWithProvider(input);
          return result;
        } catch (error) {
          if (error instanceof PaymentProviderError) {
            // Log specific error for monitoring
            console.error('Payment provider error:', error.message);
            
            // Don't retry for certain error types
            if (error.code === 'INSUFFICIENT_FUNDS') {
              throw new Error('Payment failed: Insufficient funds');
            }
          }
          
          // Re-throw for retry
          throw error;
        }
      },
    },
  },
});
```

### Custom Retry Configuration

```typescript
await ctx.jobs.payment.processPayment.dispatch(
  paymentData,
  {
    attempts: 5,
    backoff: {
      type: 'exponential',
      delay: 5000,
    },
  }
);
```

## Monitoring and Observability

### Job Status Tracking

```typescript
// src/features/jobs/jobs.controller.ts
export const jobsController = new Controller({
  name: 'jobs',
  actions: {
    getJobStatus: new Query({
      input: z.object({
        jobId: z.string(),
      }),
      handler: async ({ input, ctx }) => {
        const job = await ctx.jobs.getJob(input.jobId);
        
        if (!job) {
          throw new Error('Job not found');
        }
        
        return {
          id: job.id,
          status: job.status,
          progress: job.progress,
          data: job.data,
          result: job.returnvalue,
          error: job.failedReason,
          createdAt: job.timestamp,
          processedAt: job.processedOn,
        };
      },
    }),
  },
});
```

### Queue Metrics

```typescript
export const queueMetricsController = new Controller({
  name: 'queueMetrics',
  actions: {
    getQueueStats: new Query({
      input: z.object({
        queueName: z.string(),
      }),
      handler: async ({ input, ctx }) => {
        const stats = await ctx.jobs.getQueueStats(input.queueName);
        
        return {
          waiting: stats.waiting,
          active: stats.active,
          completed: stats.completed,
          failed: stats.failed,
          delayed: stats.delayed,
        };
      },
    }),
  },
});
```

## Performance Optimization

### Worker Scaling

```typescript
// src/workers/email-worker.ts
import { Worker } from 'bullmq';
import { redis } from '../services/redis';

const emailWorker = new Worker(
  'email',
  async (job) => {
    // Process email jobs
    return await processEmailJob(job);
  },
  {
    connection: redis,
    concurrency: 5, // Process 5 jobs concurrently
  }
);

// Graceful shutdown
process.on('SIGTERM', async () => {
  await emailWorker.close();
});
```

### Batch Processing

```typescript
export const batchJobs = new JobRouter({
  name: 'batch',
  jobs: {
    processBulkEmails: {
      input: z.object({
        emailIds: z.array(z.string()),
        templateId: z.string(),
      }),
      processor: async ({ input }) => {
        const batchSize = 50;
        const batches = chunk(input.emailIds, batchSize);
        
        for (const batch of batches) {
          await Promise.all(
            batch.map(emailId => processEmail(emailId, input.templateId))
          );
        }
        
        return { processed: input.emailIds.length };
      },
    },
  },
});
```

## Testing Background Jobs

### Unit Testing Job Processors

```typescript
// tests/jobs/email.jobs.test.ts
import { describe, it, expect, vi } from 'vitest';
import { emailJobs } from '../../src/jobs/email.jobs';

describe('Email Jobs', () => {
  it('should process welcome email job', async () => {
    const mockSendEmail = vi.fn().mockResolvedValue(true);
    vi.mock('../../src/services/email', () => ({
      sendEmail: mockSendEmail,
    }));
    
    const input = {
      userId: 'user-123',
      email: 'test@example.com',
      name: 'Test User',
    };
    
    const result = await emailJobs.jobs.sendWelcomeEmail.processor({
      input,
      job: {} as any,
    });
    
    expect(mockSendEmail).toHaveBeenCalledWith({
      to: 'test@example.com',
      subject: 'Welcome to our platform!',
      template: 'welcome',
      data: { name: 'Test User' },
    });
    
    expect(result.emailSent).toBe(true);
  });
});
```

### Integration Testing

```typescript
// tests/integration/job-flow.test.ts
import { describe, it, expect } from 'vitest';
import { testClient } from '../test-utils';

describe('Job Integration', () => {
  it('should dispatch and process welcome email job', async () => {
    const registerResult = await testClient.auth.register({
      email: 'newuser@example.com',
      password: 'password123',
      name: 'New User',
    });
    
    expect(registerResult.user.email).toBe('newuser@example.com');
    
    // Wait for job processing
    await new Promise(resolve => setTimeout(resolve, 1000));
    
    // Verify email was sent (check your email service mock)
    expect(mockEmailService.sentEmails).toHaveLength(1);
    expect(mockEmailService.sentEmails[0].to).toBe('newuser@example.com');
  });
});
```

## Comparison with Other Solutions

### vs. Traditional Cron Jobs

| Feature | Igniter.js Queues | Cron Jobs |
|---------|-------------------|----------|
| Type Safety | ✅ Full TypeScript support | ❌ No type safety |
| Error Handling | ✅ Built-in retry logic | ❌ Manual implementation |
| Monitoring | ✅ Real-time job tracking | ❌ Limited visibility |
| Scaling | ✅ Horizontal scaling | ❌ Single server |
| Dynamic Scheduling | ✅ Runtime job creation | ❌ Static configuration |

### vs. AWS SQS/Lambda

| Feature | Igniter.js Queues | AWS SQS/Lambda |
|---------|-------------------|----------------|
| Cost | ✅ Self-hosted | ❌ Pay per execution |
| Latency | ✅ Low latency | ❌ Cold start delays |
| Development | ✅ Local development | ❌ Complex local setup |
| Vendor Lock-in | ✅ Portable | ❌ AWS specific |
| Type Safety | ✅ End-to-end types | ❌ Separate type definitions |

## Best Practices

### 1. Job Design Principles

- **Idempotent operations**: Ensure jobs can be safely retried
- **Small, focused jobs**: Break complex operations into smaller jobs
- **Proper error handling**: Distinguish between retryable and non-retryable errors
- **Progress tracking**: Update job progress for long-running operations

### 2. Performance Considerations

- **Batch similar operations**: Group related tasks for efficiency
- **Use appropriate concurrency**: Balance throughput with resource usage
- **Monitor queue depth**: Prevent job backlog buildup
- **Implement circuit breakers**: Protect external services from overload

### 3. Monitoring and Alerting

- **Track job metrics**: Monitor success rates, processing times, and error rates
- **Set up alerts**: Get notified of job failures or queue backlog
- **Log appropriately**: Include context for debugging without sensitive data
- **Regular cleanup**: Remove old completed and failed jobs

## Conclusion

Igniter.js provides a robust, type-safe solution for background job processing that scales with your application. By leveraging the power of BullMQ and Redis, combined with TypeScript's type safety, you can build reliable asynchronous processing systems that enhance user experience and application performance.

The queue system integrates seamlessly with Igniter.js's RPC architecture, providing a unified development experience across your entire application stack. Whether you're processing file uploads, sending emails, or handling complex data transformations, Igniter.js queues provide the tools you need to build production-ready applications.

Start implementing background jobs in your Igniter.js application today and experience the benefits of truly asynchronous, type-safe job processing.

---

*Want to learn more about Igniter.js? Check out our [official documentation](https://igniterjs.dev) and join our [community Discord](https://discord.gg/igniterjs) for support and discussions.*