# Procedures in Igniter.js

Procedures are one of the most powerful and flexible features in Igniter.js, providing a sophisticated middleware system that enables you to create reusable, composable, and type-safe request processing logic. This comprehensive guide will take you through everything you need to know about procedures, from basic concepts to advanced patterns.

## What Are Procedures?

In Igniter.js, a **procedure** is a reusable piece of middleware that can be applied to actions or at the builder level. Think of procedures as building blocks that encapsulate common functionality like authentication, logging, rate limiting, input validation, or any custom business logic you need to run before your main handler executes.

<Accordion title="Procedures vs Traditional Middleware">
  <Field name="Type Safety" type="advantage">
    Unlike traditional middleware that often lacks type safety and composability, Igniter.js procedures are fully type-safe, composable, and provide rich context manipulation capabilities.
  </Field>
  <Field name="Context Manipulation" type="advantage">
    They can modify the request context, perform early returns, and maintain complete type inference throughout the chain.
  </Field>
</Accordion>

Procedures operate within the **request lifecycle**, executing before your action handlers and having the ability to:

- **Validate and transform input data**
- **Authenticate and authorize requests**
- **Log request information**
- **Implement rate limiting**
- **Add custom context data**
- **Perform early returns** (like redirects or error responses)
- **Access the global application context** (database connections, services, etc.)
- **Chain with other procedures** for complex workflows

## Core Concepts

### Procedure Context

Every procedure receives an `IgniterProcedureContext` object that contains all the information about the current request:

### Understanding the Procedure Context: A Properties Breakdown

To understand the `IgniterProcedureContext` object that every procedure receives, you can expand the section below to see a detailed breakdown of its properties.

<Accordion title="IgniterProcedureContext Properties">
  <Field name="request" type="object" required>
    The incoming request object containing headers, query parameters, body, cookies, and more.
  </Field>
  <Field name="context" type="object" required>
    The global application context containing database connections, services, configuration, and other shared resources.
  </Field>
  <Field name="response" type="object" required>
    The response builder object with methods to create successful or error responses.
  </Field>
  <Field name="next" type="function" required>
    Function to continue to the next middleware or call the final handler.
  </Field>
</Accordion>

The context is the primary way procedures interact with the request lifecycle, providing a clean and type-safe interface for middleware operations.

## Creating Your First Procedure

Let's start with a simple example using the `igniter.procedure` function. We'll create a request logging procedure:

```typescript
import { igniter } from '@/igniter';

// Create a simple logging procedure
export const requestLogger = igniter.procedure({
  name: 'RequestLogger',
  handler: async ({ request, context, response, next }) => {
    const startTime = Date.now();
    
    // Use logger from global context if available
    const logger = context.logger || console;
    logger.log(`[${new Date().toISOString()}] ${request.method} ${request.url}`);
    
    // Continue to the next middleware or handler
    const result = await next();
    
    const duration = Date.now() - startTime;
    logger.log(`Request completed in ${duration}ms`);
    
    return result;
  },
});
```

This procedure:
1. **Logs the incoming request** with timestamp, method, and URL
2. **Calls `next()`** to continue the middleware chain
3. **Logs the completion time** after the request is processed
4. **Returns the result** from the next middleware or handler

### Using the Procedure

Once created, you can use this procedure in your controllers:

### Action-Level Procedures

```typescript
export const userController = igniter.controller({
  name: 'UserController',
  path: '/users',
  actions: {
    getUser: igniter.query({
      path: '/:id',
      // Apply the procedure only to this action
      use: [requestLogger],
      handler: ({ request, response }) => {
        return response.success({ user: { id: request.params.id } });
      },
    }),
  },
});
```

<Accordion title="Future Enhancements">
  <Field name="Router and Controller Level Procedures" type="roadmap">
    Currently, procedures can only be used at the action level or builder level. Support for router and controller level procedures is planned for future releases. You can track this feature request and vote for it on [GitHub Issue #13](https://github.com/felipebarcelospro/igniter-js/issues/13).
  </Field>
</Accordion>



## Best Practices

Following established best practices when creating procedures ensures your code remains maintainable, reusable, and type-safe. These guidelines will help you build robust middleware that integrates seamlessly with the Igniter.js ecosystem.

Proper procedure design not only improves code quality but also enhances developer experience by making your APIs more predictable and easier to debug. Each practice below addresses common challenges developers face when building production applications.

<Accordion title="Keep Procedures Focused">
  Each procedure should have a single, well-defined responsibility. This follows the Single Responsibility Principle and makes your code more maintainable and testable.

  ```typescript
  // Good: Focused on authentication only
  export const authProcedure = igniter.procedure({
    name: 'Authentication',
    handler: async ({ request, response, next }) => {
      // Only handle authentication logic
    },
  });

  // Good: Focused on logging only
  export const loggingProcedure = igniter.procedure({
    name: 'Logging',
    handler: async ({ request, response, next }) => {
      // Only handle logging logic
    },
  });

  // Avoid: Mixing multiple concerns
  export const authAndLoggingProcedure = igniter.procedure({
    name: 'AuthAndLogging',
    handler: async ({ request, response, next }) => {
      // Don't mix authentication and logging in one procedure
    },
  });
  ```
</Accordion>

<Accordion title="Use Descriptive Names">
  Give your procedures clear, descriptive names that indicate their purpose. This makes your code self-documenting and easier to understand.

  ```typescript
  // Good - Clear and descriptive
  export const jwtAuthenticationProcedure = igniter.procedure({
    name: 'JWTAuthentication',
    handler: async ({ next }) => next(),
  });
  
  export const requestRateLimitProcedure = igniter.procedure({
    name: 'RequestRateLimit',
    handler: async ({ next }) => next(),
  });
  
  export const inputValidationProcedure = igniter.procedure({
    name: 'InputValidation',
    handler: async ({ next }) => next(),
  });

  // Avoid - Vague and unclear
  export const authProc = igniter.procedure({
    name: 'Auth',
    handler: async ({ next }) => next(),
  });
  
  export const middleware1 = igniter.procedure({
    name: 'Middleware1',
    handler: async ({ next }) => next(),
  });
  ```
</Accordion>

<Accordion title="Handle Errors Gracefully">
  Always handle potential errors in your procedures to prevent unhandled exceptions from crashing your application.

  ```typescript
  export const safeProcedure = igniter.procedure({
    name: 'SafeProcedure',
    handler: async ({ request, response, next }) => {
      try {
        // Your procedure logic
        const result = await someAsyncOperation();
        return next();
      } catch (error) {
        console.error('Procedure error:', error);
        return response.error({
          message: 'Procedure failed',
          statusCode: 500,
        });
      }
    },
  });
  ```
</Accordion>

<Accordion title="Use Schema Validation for Configuration">
  When creating configurable procedures, always use schema validation to ensure type safety and runtime validation.

  ```typescript
  const optionsSchema = z.object({
    timeout: z.number().min(1000).max(30000).default(5000),
    retries: z.number().min(0).max(5).default(3),
  });

  export const configurableProcedure = igniter.procedure({
    name: 'ConfigurableProcedure',
    schema: optionsSchema,
    handler: async ({ options, next }) => {
      // options are now type-safe and validated
    },
  });
  ```

  <Field name="Schema Type Safety" type="feature">
    Schema validation ensures type safety for all configuration options.
  </Field>
  <Field name="Runtime Validation" type="feature">
    Invalid configurations are caught at runtime with clear error messages.
  </Field>
  <Field name="Configuration Default Values" type="feature">
    Schema provides sensible defaults for optional configuration parameters.
  </Field>
</Accordion>

<Accordion title="Document Your Procedures">
  Provide clear documentation for your procedures, especially their configuration options, to help other developers understand and use them effectively.

  ```typescript
  /**
   * Rate limiting procedure that restricts the number of requests per time window.
   * 
   * @example
   * ```typescript
   * use: [
   *   rateLimitProcedure({
   *     maxRequests: 100,
   *     windowMs: 60000, // 1 minute
   *     message: 'Too many requests'
   *   })
   * ]
   * ```
   */
  export const rateLimitProcedure = igniter.procedure({
    name: 'RateLimit',
    schema: z.object({
      /** Maximum number of requests allowed in the time window */
      maxRequests: z.number().min(1).default(100),
      /** Time window in milliseconds */
      windowMs: z.number().min(1000).default(60000),
      /** Error message to return when rate limit is exceeded */
      message: z.string().default('Too many requests'),
    }),
    handler: async ({ options, request, response, next }) => {
      // Implementation
    },
  });
  ```

  <Field name="JSDoc Comments" type="practice">
    Use JSDoc comments to describe the procedure's purpose and usage.
  </Field>
  <Field name="Usage Examples" type="practice">
    Provide clear examples showing how to configure and use the procedure.
  </Field>
  <Field name="Parameter Documentation" type="practice">
    Document each configuration parameter with inline comments.
  </Field>
</Accordion>





## Conclusion

Procedures are a fundamental building block of Igniter.js applications, providing a powerful and flexible way to implement cross-cutting concerns in your API using the `igniter.procedure` function. By understanding how to create, compose, and use procedures effectively, you can build more maintainable, reusable, and type-safe applications.

### Key Takeaways

<Accordion title="Essential Procedure Concepts">
  <Field name="Cross-Cutting Concerns" type="concept">
    Use procedures for authentication, logging, validation, and other shared functionality across your application.
  </Field>
  <Field name="Type-Safe Context" type="concept">
    Leverage the type-safe context system for secure data sharing between procedures and handlers.
  </Field>
  <Field name="Composition" type="concept">
    Compose procedures to build complex middleware chains with predictable execution order.
  </Field>
  <Field name="Single Responsibility" type="concept">
    Follow the single responsibility principle to create maintainable and testable code.
  </Field>
  <Field name="Best Practices" type="concept">
    Keep procedures focused, use descriptive names, and implement proper error handling.
  </Field>
</Accordion>

<Accordion title="Next Steps">
  <Field name="Ready to Build" type="next-step">
    With this comprehensive understanding of procedures, you're ready to build sophisticated, production-ready APIs with Igniter.js. Explore [Controllers and Actions](/docs/core-concepts/controllers) and [Request and Response Handling](/docs/core-concepts/request-response) to complete your knowledge.
  </Field>
</Accordion>